Simple buffer:    Depth buffer: [Or 1-3, with 0 meaning not-in-buffer].
 . . . . .          . . . . .
 . : : : .          . 2 1 1 .
 . : : : .          . 2 1 0 .
 . : : : p          . 2 1 0 p
 . : : : p          . 2 1 0 p
 . : : : p          . 2 1 0 p

In the buffered cases, how does this look?

Simple buffer hit:

b  b  b  .  .       .  .  .  .  .
b  b: b:  :  .      .  b: b: b:  .
b  b: b:  :  .      .  b: b: b:  .
.   :  :  :  p  ->  .  b: b: b:  p
.   :  :  :  p      .   :  :  :  p
.   :  :  :  p      .   :  :  :  p

All ball cells going into the simple buffer know it, since the buffer moves
into cells at the same 1 cell per cycle that the ball cells do.  Ball cells
can spread depth knowledge as well.  Hmm...but if they come from above, do
they need to know depth-to-X as well as depth-to-Y?  Probably.  Can they tell
that?  In the special case of depth 3, yes, because a cell can tell which
buffer cell it is by its neighbors.  If there were a 4+ thickness buffer, the
inner cells would be indistinguishable.

OK, review: how do we know Y depth in the simple case above?  The buffer region
will have to have the same PADDLE_PIXEL, extended to the whole region, in order
to have the correct bounce angle, so we'll use that.  So it'll really be a depth
buffer, at least in Y, automatically.  We could use a 4-pixel paddle with a
2-pixel buffer top and bottom, and that'd be the same 3 bits, but only 6 pixels
of coverage.  So we'd need to make the board 48 pixels high instead of 64 to use
the same 3-bit destination height.  Better: a 6-pixel paddle with 2 pixel
buffer, for 8 pixels of coverage over 10 pixels, allowing a 64-pixel board.  Use
PADDLE_PIXEL for the inner 8 pixels of paddle plus buffer.  Then the outermost
pixels repeat the PADDLE_PIXEL values, so they're 0, 0, 1, 2, 3, 4, 5, 6, 7, 7.
Ball pixels coming in can look at neighbors to see which 0 or 7 it is.
Hmm...really, since PADDLE_PIXEL is used for bounce angle, and the middle 2 or
so will share the same angle, perhaps we should do 0, 1, 2, 3, 3, 4, 4, 5, 6, 7
instead.  We will need to make sure that we add 2 pixels of space at the top and
bottom so that the buffer never actually hits the wall; we can't lose a ball in
the gap anyway.


Simple buffer barely-miss:
b  b  b  .  .       .  b  b  b  .
b  b: b:  :  :      .  b: b: b:  :
b  b: b:  :  :      .  b: b: b:  :
.   :  :  :  p  ->  .   :  :  :  p
.   :  :  :  p      .   :  :  :  p
.   :  :  :  p      .   :  :  :  p

Here the y-depth [from PADDLE_PIXEL] is 2 and the x-depth 3, so it's a miss.

State in the paddle and buffer:
  IsPaddle/IsPaddleBuffer:
    2 global ID bits, 2 [4?] for buffers, 1 for paddle buffer
  IsRightNotLeft:0 [reuse global buffer bits for that]
  paddlePixel pixel:3
  Where-am-I location:6
  Where-am-I-going counter/altitude:3
  When-can-I-leave [counter for info to propagate through thickness of paddle]:2

All that state needs to get stored in the ball as well, since it needs to be
restored as the ball moves away.  Hmm...or can we just restore it from the
neighboring paddle cells?  That would save a lot of bits in the ball, which
probably has other uses for them.  Seems likely that we can do that; it's a
bit more complex, but worth it.  Umm...actually no, not without storing the
depth bits as well, otherwise the left edge of the right paddle buffer, coming
down out from under a ball, doesn't know where its top border is.  Still, we
can pull the counters from our paddle-cell neighbors, just not the single bit
for IsPaddleBuffer.  Oops--that's problematic as well, with larger balls.  If
you've got a paddle buffer inside a ball, it needs to know its movement
parameters, and can't pull them from neighbors if it's deep inside the ball.
Note that movement parameters don't change when there's a ball around, though,
nor will an AI paddle reverse directions while we're near it.  And the non-AI
paddle will get special treatment that should make things easier and not require
extra bits.

Example bit allocations for a 3-pixel ball and a height-64 [so 6 bits] board
with flush paddle [so no paddleBallSignal].

Global: 2: type [isBall, isBackground, isAIPaddle, isWall]
  We can possibly use a lower bit from isBackground or isWall and use it for the
  non-AI paddle.
  Total: 2
Ball: 2:depthX, 2:depthY, 2 depthYIntoPaddleBuffer, 1:down, 1:right, 3:moveIndex, 2:moveState, 1:decimator [shared with paddle].
  Total: 14
Paddle/PaddleBuffer: 6:position, 3:dest, 2:moveSyncDelayCounter, 1:pixel,
  1:decimator, 1:isBuffer.  We'll either have to save/restore the Y buffer or
  we'll have to figure it out from position and pixel...yeah, we can do that,
  and save the bit...unless it's wasted saving because the ball and background
  need to store it, but it may not be.
  Total: 14-15 [decimator shared with ball]
Background/Buffer: 4:bufferFlags
  Total: 4 [update--can reduce this to 3 or maybe 2.  See * below]

The ball needs to hold all the paddle buffer bits as it goes through, otherwise
a corner of the buffer, coming out from under the ball, won't have anywhere to
grab them from.  So 14 ball bits plus 14 - 1 is 27 shared bits, plus 2 ID bits
is 29, plus 4 buffer bits puts us over at 33.

Where can we shave bits?  Cut down the choices of move angle from 30 to 15 to
save 2 bits [1 state, 1 index].

Is there anything we can do to drop 1 of the y buffer bits and reuse the other?
The top and bottom rows of the y buffer can tell which they are by their
neighbors.  The middle row doesn't...but does it need to?  Probably.  A ball
moving in can't tell whether to count up or down...except that it knows its
count!  [*] So if I'm a middle cell, and a ball's coming in from below, and it's
got depth 1, it must be entering rather than leaving.  If it has depth 3, it
must be leaving.  OK, so that's another bit saved.  Can we do the same thing
with the x bits?  I don't see why not.  2 bits saved.  TODO: implement this on
bigbounce.js.

What about the AI message?  It should get generated from a background cell that
sees 3 ball cells stacked vertically to its side, newly-bounced, with the full
paddle depths set.  And the respawn message gets generated by a wall cell that
sees wall above and below and 3 ball cells next to it.

DepthX and depthXIntoPaddleBuffer would be different, since the paddle
is 1 pixel in from the wall, but we could cheat that by making the paddle
collinear with the wall, and then just keeping track of the single bit of
whether we're in the paddle buffer or not, which might possibly be shared with
the depthYIntoPaddleBuffer [== if it's nonzero].  Hmm...if we've got a separate
bit for depthXIsInPaddleBuffer somehow, then we count up to 3 for depth and then
bounce, or overflow the 2 bits to 4, meaning we missed.  That could work even
without flush paddle.  However, flush paddle saves us from needing
PADDLE_BALL_SIGNAL.  And at the overflow we'd need to have a bit to indicate
that so that we could tell the ball to vanish once it hit the wall; if it
vanished the cycle before that, the wall would never know to send the respawn
message.  So flush seems to be the way to go.

Message-passing: the background passes info for the AI sideways; it'll need
a direction indicator as well as the target offset.
The end walls pass scoring info outward to the scoreboard, and must also pass
the ball-spawn message to the respawn point.  Perhaps we should have 2 respawn
points, one on each side.  Pass the message up to the top, along the wall,
then down to the respawn point.  It would be good if the respawn happened
after the score increment.  It would also be good if the score on the left
corresponded to the paddle on the left, although if I want the score to count
up, which I do, that's tricky.  So scoring messages have to get across to a
scoreboard on the opposite side, then respawn the ball on the way back,
perhaps?


      -----------------------------------------------------------
 S S  |                                                         | S S
      |                                                         |
      |                                                        P|
      |                                                        P|
      |                                  B                     P|
      |                                                         |
      |P                                                        |
      |P                                                        |
      |P                                                        |
      |                                                         |
      |                                                         |
      -----------------------------------------------------------


Here the scores are at the top-center.  Let's make the message wave
visible, so you can watch it move up the wall, to the center.  There it splits
and sends a scoring message up to the scoreboard [saying which player to
increment] and down to the respawn point.  We can either send the score the
whole way there, in which case the walls have to know the score through their
whole length, or we can just send an increment, in which case it's hard to know
when the game ends before respawning.

The respawn point can also be the center of a "game over" message if the message
splitter at the top keeps track of when the game ends.

                            | S S  |  S S  |
      -----------------------------------------------------------
      |                            |                            |
      |                            |                            |
      |                            |                           P|
      |                            |                           P|
      |                            |     B                     P|
      |                            r                            |
      |P                                                        |
      |P                                                        |
      |P                                                        |
      |                                                         |
      |                                                         |
      -----------------------------------------------------------

Bits we want visible:
isBall, isWall, isPaddle, counter + message displays, the scoring message
moving up the wall from a ball impact.
Bits we want invisible or at least unobtrusive:
The AI message.
Bits I'm not sure about yet:
The ball respawn message coming down from the top.

Counter messages through the counter region:
  Direction bit for routing: No, all directions.
  Spread: all directions
  Payload: score counter, likely 4 bits.

Board layout:

We'll need to interpret the ball-hit message before the respawn, so that we
don't respawn on game over.  We can do that at the top-wall-center pixel.  If it
keeps track of the score of each player, it can decide when the game is over and
either send the respawn message or not.  It can also initiate the game-over
message, wherever we want to display that.

So top-wall-center needs, in addition to 2 type bits, 1 subtype bit, and 2
message bits [present + direction] a counter for each score, say at least 4 bits
with game going to 15.  Messages will always go up, and will only go down on
score less than the max, so we'll need a separate signal for up messages vs.
down, so at least 1 more bit there for message and a second for game-over.
That's still only 15 or so, so no problem there.

----------------------------------------------------------------
|       1 4         |   G A M E   O V E R   |       0 3        |
----------------------------------------------------------------
|                                                              |
|                                                              |
|                                                              |
|                                                              |
|                                                              |
|                                                              |
|                                                              |
----------------------------------------------------------------

Here the GAME OVER is in the middle, which looks good, but if the message comes
from the middle, it would naturally appear before the final score increment.  
We can put a delay in there by using the counter display for the game over; just
have the whole message trigger on a high number, and have the message trigger a
single-cell counter that counts up to it and then stops there.

Another option for game-over and score/respawn messages: the message comes up
from the paddle, across all the way to the opposite score [as its direction
tells the fork under each score whether to grab it or not], up into the score,
and then spreads out, hitting the border of game-over.  game-over looks for a
score increment, and lights up on the final score.  There's a cell at its bottom
center that sees an increment that's not the final score, and triggers a
straight-down respawn message with LR in it.  We'd just need a few wall subtypes
to deal with the routing.

--------------------------------------------------------------------------------

Optimization: it turns out we were spending something like 2/3 of our time in
BitManager.getRecordInternal, with many of those calls from isPaddle, isBall,
etc.  I made some dedicated functions to replace those, and that improved things
from 15-25fps on my home laptop to 45-60fps [inconsistent and with a slow,
jittery startup].  On my work laptop it'd been a fairly consistent 55-60fps
before optimization, but that's a much newer machine.  To improve further, I'd
like to remove the need for that function entirely.  Some thoughts:

When registering a bitfield, return its record, either as something to pass to
BitManager functions instead of the string, or as a class object that holds the
BitManager methods.  This would remove the namespace validation that the current
functions do, though, so we should have each record keep track of its namespace,
and do the mask check before carrying out the requested function.

That check too could be turned off as asserts could be, but if we can afford to
keep it on indefinitely, that'd be nice.  We don't currently ever turn off
asserts, and even if we did, we have no preprocessor [yet], so it won't save all
that much.  A JS compiler could take care of that for us.

It'll be easiest to implement the new functions without breaking the old if we
make a new class and methods for the new objects, although there may be some
duplication.  The new methods should be a lot smaller, though, and maybe they
can share some core code.  All the declare/combine/alias core will be shared,
since the central database will still be the same.
