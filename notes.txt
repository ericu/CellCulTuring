Simple buffer:    Depth buffer: [Or 1-3, with 0 meaning not-in-buffer].
 . . . . .          . . . . .
 . : : : .          . 2 1 1 .
 . : : : .          . 2 1 0 .
 . : : : p          . 2 1 0 p
 . : : : p          . 2 1 0 p
 . : : : p          . 2 1 0 p

In the buffered cases, how does this look?

Simple buffer hit:

b  b  b  .  .       .  .  .  .  .
b  b: b:  :  .      .  b: b: b:  .
b  b: b:  :  .      .  b: b: b:  .
.   :  :  :  p  ->  .  b: b: b:  p
.   :  :  :  p      .   :  :  :  p
.   :  :  :  p      .   :  :  :  p

All ball cells going into the simple buffer know it, since the buffer moves
into cells at the same 1 cell per cycle that the ball cells do.  Ball cells
can spread depth knowledge as well.  Hmm...but if they come from above, do
they need to know depth-to-X as well as depth-to-Y?  Probably.  Can they tell
that?  In the special case of depth 3, yes, because a cell can tell which
buffer cell it is by its neighbors.  If there were a 4+ thickness buffer, the
inner cells would be indistinguishable.

OK, review: how do we know Y depth in the simple case above?  The buffer region
will have to have the same PADDLE_PIXEL, extended to the whole region, in order
to have the correct bounce angle, so we'll use that.  So it'll really be a depth
buffer, at least in Y, automatically.  We could use a 4-pixel paddle with a
2-pixel buffer top and bottom, and that'd be the same 3 bits, but only 6 pixels
of coverage.  So we'd need to make the board 48 pixels high instead of 64 to use
the same 3-bit destination height.  Better: a 6-pixel paddle with 2 pixel
buffer, for 8 pixels of coverage over 10 pixels, allowing a 64-pixel board.  Use
PADDLE_PIXEL for the inner 8 pixels of paddle plus buffer.  Then the outermost
pixels repeat the PADDLE_PIXEL values, so they're 0, 0, 1, 2, 3, 4, 5, 6, 7, 7.
Ball pixels coming in can look at neighbors to see which 0 or 7 it is.
Hmm...really, since PADDLE_PIXEL is used for bounce angle, and the middle 2 or
so will share the same angle, perhaps we should do 0, 1, 2, 3, 3, 4, 4, 5, 6, 7
instead.  We will need to make sure that we add 2 pixels of space at the top and
bottom so that the buffer never actually hits the wall; we can't lose a ball in
the gap anyway.


Simple buffer barely-miss:
b  b  b  .  .       .  b  b  b  .
b  b: b:  :  :      .  b: b: b:  :
b  b: b:  :  :      .  b: b: b:  :
.   :  :  :  p  ->  .   :  :  :  p
.   :  :  :  p      .   :  :  :  p
.   :  :  :  p      .   :  :  :  p

Here the y-depth [from PADDLE_PIXEL] is 2 and the x-depth 3, so it's a miss.

State in the paddle and buffer:
  IsPaddle/IsPaddleBuffer:
    2 global ID bits, 2 [4?] for buffers, 1 for paddle buffer
  IsRightNotLeft:0 [reuse global buffer bits for that]
  paddlePixel pixel:3
  Where-am-I location:6
  Where-am-I-going counter/altitude:3
  When-can-I-leave [counter for info to propagate through thickness of paddle]:2

All that state needs to get stored in the ball as well, since it needs to be
restored as the ball moves away.  Hmm...or can we just restore it from the
neighboring paddle cells?  That would save a lot of bits in the ball, which
probably has other uses for them.  Seems likely that we can do that; it's a
bit more complex, but worth it.  Umm...actually no, not without storing the
depth bits as well, otherwise the left edge of the right paddle buffer, coming
down out from under a ball, doesn't know where its top border is.  Still, we
can pull the counters from our paddle-cell neighbors, just not the single bit
for IsPaddleBuffer.  Oops--that's problematic as well, with larger balls.  If
you've got a paddle buffer inside a ball, it needs to know its movement
parameters, and can't pull them from neighbors if it's deep inside the ball.
Note that movement parameters don't change when there's a ball around, though,
nor will an AI paddle reverse directions while we're near it.  And the non-AI
paddle will get special treatment that should make things easier and not require
extra bits.

Example bit allocations for a 3-pixel ball and a height-64 [so 6 bits] board
with flush paddle [so no paddleBallSignal].

Global: 2: type [isBall, isBackground, isAIPaddle, isWall]
  We can possibly use a lower bit from isBackground or isWall and use it for the
  non-AI paddle.
  Total: 2
Ball: 2:depthX, 2:depthY, 1:down, 1:right, 3:moveIndex, 2:moveState, 1:decimator [shared with paddle].
  Total: 14
Paddle/PaddleBuffer: 6:position, 3:dest, 2:moveSyncDelayCounter, 1:pixel,
  1:decimator, 1:isBuffer.  We'll either have to save/restore the Y buffer or
  we'll have to figure it out from position and pixel...yeah, we can do that,
  and save the bit...unless it's wasted saving because the ball and background
  need to store it, but it may not be.
  Total: 14 [decimator shared with ball]
Background/Buffer: 2:bufferFlags
  Total: 2

The ball needs to hold all the paddle buffer bits as it goes through, otherwise
a corner of the buffer, coming out from under the ball, won't have anywhere to
grab them from.  So 14 ball bits plus 14 - 1 is 27 shared bits, plus 2 ID bits
is 29, plus 2 buffer bits puts us at 31, leaving 1 for the high alpha bit.

Where can we shave bits?  Cut down the choices of move angle from 30 to 15 to
save 2 bits [1 state, 1 index].

What about the AI message?  It should get generated from every background cell
that sees a ball cell to its side, newly-bounced, with the full paddle depths
set.  And the respawn message gets generated by a wall cell that sees wall above
and below and 3 ball cells next to it.

Question: should the paddle buffer region be paddle or background?  Which is
more efficient bit-wise?  Hmm...we normally have the ball overlap onto the
background, so that would be more natural.  We probably don't want isBall and
isPaddle at the same time.  It's not impossible, just a little less intuitive.
Bitwise, it probably makes no difference.

Updated view of bits:

Global ID bits: 2
Global high alpha [ideally]: 1

The paddle has its own state:
  * position:6, destination:3, isBuffer:1 [so we're in the paddle at all],
    pixel:1, moveSyncDelayCounter:2, decimator: 1.

The ball has its own state:

  * depthX:2, depthY:2, down:1, right:1, moveIndex:3, moveState:2, decimator:1.

The background has state that doesn't need restoring, too:

  * messageActive:1, messageHNotV:1, messageRNotL: 1, message payload: 3.

The ball needs to pick up and put back down some shared bits:

  * Paddle state: position:6, destination:3, isBuffer:1 [so we're in the
    paddle at all], pixel:1.  We *don't* need to carry moveSyncDelayCounter,
    since it will be zero!  Decimator is shared.
  * Background state: isBuffer:2, isRespawn:1.

DepthX and depthXIntoPaddleBuffer would be different, since the paddle
is 1 pixel in from the wall, but we could cheat that by making the paddle
collinear with the wall, and then just keeping track of the single bit of
whether we're in the paddle buffer or not.  Hmm...if we've got a separate
bit for depthXIsInPaddleBuffer somehow, then we count up to 3 for depth and then
bounce, or overflow the 2 bits to 4, meaning we missed.  That could work even
without flush paddle.  However, flush paddle saves us from needing
PADDLE_BALL_SIGNAL.  And at the overflow we'd need to have a bit to indicate
that so that we could tell the ball to vanish once it hit the wall; if it
vanished the cycle before that, the wall would never know to send the respawn
message.  So flush seems to be the way to go.

Message-passing:

The end walls pass scoring info outward to the scoreboard, and must also pass
the ball-spawn message to the respawn point.  Perhaps we should have 2 respawn
points, one on each side.  Pass the message up to the top, along the wall,
then down to the respawn point.  It would be good if the respawn happened
after the score increment.  It would also be good if the score on the left
corresponded to the paddle on the left, although if I want the score to count
up, which I do, that's tricky.  So scoring messages have to get across to a
scoreboard on the opposite side, then respawn the ball on the way back,
perhaps?


      -----------------------------------------------------------
 S S  |                                                         | S S
      |                                                         |
      |                                                        P|
      |                                                        P|
      |                                  B                     P|
      |                                                         |
      |P                                                        |
      |P                                                        |
      |P                                                        |
      |                                                         |
      |                                                         |
      -----------------------------------------------------------


Here the scores are at the top-center.  Let's make the message wave
visible, so you can watch it move up the wall, to the center.  There it splits
and sends a scoring message up to the scoreboard [saying which player to
increment] and down to the respawn point.  We can either send the score the
whole way there, in which case the walls have to know the score through their
whole length, or we can just send an increment, in which case it's hard to know
when the game ends before respawning.

The respawn point can also be the center of a "game over" message if the message
splitter at the top keeps track of when the game ends.

                            | S S  |  S S  |
      -----------------------------------------------------------
      |                            |                            |
      |                            |                            |
      |                            |                           P|
      |                            |                           P|
      |                            |     B                     P|
      |                            r                            |
      |P                                                        |
      |P                                                        |
      |P                                                        |
      |                                                         |
      |                                                         |
      -----------------------------------------------------------

Bits we want visible:
isBall, isWall, isPaddle, counter + message displays, the scoring message
moving up the wall from a ball impact.
Bits we want invisible or at least somewhat subtle:
The AI message.
Bits I'm not sure about yet:
The ball respawn message coming down from the top.

Counter messages through the counter region:
  Direction bit for routing: No, all directions.
  Spread: all directions
  Payload: score counter, likely 4 bits.

Board layout:

We'll need to interpret the ball-hit message before the respawn, so that we
don't respawn on game over.  We can do that at the top-wall-center pixel.  If it
keeps track of the score of each player, it can decide when the game is over and
either send the respawn message or not.  It can also initiate the game-over
message, wherever we want to display that.

So top-wall-center needs, in addition to 2 type bits, 1 subtype bit, and 2
message bits [present + direction] a counter for each score, say at least 4 bits
with game going to 15.  Messages will always go up, and will only go down on
score less than the max, so we'll need a separate signal for up messages vs.
down, so at least 1 more bit there for message and a second for game-over.
That's still only 15 or so, so no problem there.

----------------------------------------------------------------
|       1 4         |   G A M E   O V E R   |       0 3        |
----------------------------------------------------------------
|                                                              |
|                                                              |
|                                                              |
|                                                              |
|                                                              |
|                                                              |
|                                                              |
----------------------------------------------------------------

Here the GAME OVER is in the middle, which looks good, but if the message comes
from the middle, it would naturally appear before the final score increment.  
We can put a delay in there by using the counter display for the game over; just
have the whole message trigger on a high number, and have the message trigger a
single-cell counter that counts up to it and then stops there.

Another option for game-over and score/respawn messages: the message comes up
from the paddle, across all the way to the opposite score [as its direction
tells the fork under each score whether to grab it or not], up into the score,
and then spreads out, hitting the border of game-over.  game-over looks for a
score increment, and lights up on the final score.  There's a cell at its bottom
center that sees an increment that's not the final score, and triggers a
straight-down respawn message with LR in it.  We'd just need a few wall subtypes
to deal with the routing.

--------------------------------------------------------------------------------

To add paddles to bigrespawn:
* First add a trough for the paddle, moving the side buffers in and making the
  trough region handle respawn. DONE
* Then add paddles that bounce but don't move. DONE
* Then add decimation. DONE
* Then add paddle motion, but no AI messages. DONE
* Then add sending AI messages, but not using them.
* Then add using AI messages and move delays.

* At some point, add AI messages on respawn; they could be sent early by the
ball at destruction, which guarantees plenty of time to get there but looks a
bit weird, or could be sent at respawn itself, although that gives much less
warning.

--------------------------------------------------------------------------------

Other ways to shave bits:

When counting into the depth buffer, we can go to 4 instead of 3 by turning
around at overflow instead of when we hit 3.  We can't maintain an accurate
count on the way out, but we don't actually need to--we can turn around and call
it 3 instead of 4, and then count down too early, and ignore underflow on the
last step out.  Hmm...will that confuse the ball-death-signal code?  We'd be at
depth 0 while still inside.  Can we detect that situation and work around it
somehow?  Ug--even if we can, this will destroy the trick we used to tell max
from min buffers.  Nevermind.

Use PADDLE_BUFFER_FLAG as a namespace bit for balls.  All the paddle buffer bits
go in that namespace, but then we can put BUFFER_Y_FLAG in its complement, since
that information can be derived from the paddle's position and paddlePixel.  If
desired, we can use that one saved bit to implement a death flag instead of
using the zeroed depth counter in the above hack.  But then we're still short a
bit to use for decoration.
--------------------------------------------------------------------------------

Consider making DECIMATOR a global bit.  Almost everybody uses it, and it would
be nice just to be able to grab it and negate it everywhere.  It's not much more
work for the empty background; might even be a wash, with less checking for if
you need it or not.  The only other minus would be having it in the scoreboard,
which has no need for it, but that seems fairly trivial, especially if it's not
a very visible bit.

--------------------------------------------------------------------------------
The checkerboard ball state will probably work!  We can save a ton of bits that
way.  Make a ball out of alternating pixels, where some have all the ball motion
info and the others have all the collected paddle/buffer info.  Both need the
isPaddleBuffer and isBall bits.  When you need one or the other namespace of
info, there's always a pixel within reach that has it.  The only thing to watch
out for is that the leading corner when moving diagonally must have the ball
info, as it may be the only ball pixel that the target pixel can see.  That's
probably pretty easy to arrange, though, for most odd ball sizes, and anybody
outside the ball should be able to see the paddle buffer state directly in most
cases, and see at least one paddle buffer pixel inside the ball otherwise.

7:
   x.x
  x.x.x
 x.x.x.x
 .x.x.x.
 x.x.x.x
  x.x.x
   x.x

5:
   x
  x.x
 x.x.x
  x.x
   x

4: does that work?  Probably.  And the bitflag would make for nice shading here,
too.  Start with a 3x3 ball for the switchover, then grow to this once it's
working.

   xx
  x..x
  x..x
   xx

3: x
  x.x
   x
