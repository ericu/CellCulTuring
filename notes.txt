TODO:
Add GAME OVER message [flashing?] and of course game-end logic.
Add user input.
Nicer scoreboard font using 1-hot encoding?
Add a bit or two to make the paddle brighter; we've got it to spare.

Consider that crazy optimization for more bits, to do a larger ball with better
shading?  How many bits do we need, and how many do we have?

Needed:
  2:ball:BUFFER_X/Y_DEPTH_COUNTER,
  2:bg+ball:MIN/MAX for BUFFER_X/Y_FLAG,
  1+:ball:shading,
  0+:ball+bg+paddle bigger paddle means ideally a larger paddlePixel range,
  1:bg+ball?:isCenterRespawn/respawnPhase2 will probably need at least one more
  bit, but may be background-only.
  1:bg+ball:PADDLE_MOVE_DELAY_COUNTER.
  Minimum of 6 for ball.
--------------------------------------------------------------------------------

Other ways to shave bits:

0: When counting into the depth buffer, we can go to 4 instead of 3 by turning
around at overflow instead of when we hit 3.  We can't maintain an accurate
count on the way out, but we don't actually need to--we can turn around and call
it 3 instead of 4, and then count down too early, and ignore underflow on the
last step out.  Hmm...will that confuse the ball-death-signal code?  We'd be at
depth 0 while still inside.  Can we detect that situation and work around it
somehow?  Ug--even if we can, this will destroy the trick we used to tell max
from min buffers.  Nevermind.

1: Use PADDLE_BUFFER_FLAG as a namespace bit for balls.  All the paddle buffer
bits go in that namespace, but then we can put BUFFER_Y_FLAG in its complement,
since that information can be derived from the paddle's position and
paddlePixel.  If desired, we can use that one saved bit to implement a death
flag instead of using the zeroed depth counter in the above hack.  But then
we're still short a bit to use for decoration.

2: FULL_ALPHA is currently 3 bits; we certainly wouldn't miss the bottom one,
and could function without the bottom two if necessary.
--------------------------------------------------------------------------------

Consider making DECIMATOR a global bit.  Almost everybody uses it, and it would
be nice just to be able to grab it and negate it everywhere.  It's not much more
work for the empty background; might even be a wash, with less checking for if
you need it or not.  The only other minus would be having it in the scoreboard,
which has no need for it, but that seems fairly trivial, especially if it's not
a very visible bit.

--------------------------------------------------------------------------------
The checkerboard ball state will probably work!  We can save a ton of bits that
way.  Make a ball out of alternating pixels, where some have all the ball motion
info and the others have all the collected paddle/buffer info.  Both need the
isPaddleBuffer and isBall bits.  When you need one or the other namespace of
info, there's always a pixel within reach that has it.  The only thing to watch
out for is that the leading corner when moving diagonally must have the ball
info, as it may be the only ball pixel that the target pixel can see.  That's
probably pretty easy to arrange, though, for most odd ball sizes, and anybody
outside the ball should be able to see the paddle buffer state directly in most
cases, and see at least one paddle buffer pixel inside the ball otherwise.

7:
   x.x
  x.x.x
 x.x.x.x
 .x.x.x.
 x.x.x.x
  x.x.x
   x.x

5:
   x
  x.x
 x.x.x
  x.x
   x

4: does that work?  Probably.  And the bitflag would make for nice shading here,
too.  Start with a 3x3 ball for the switchover, then grow to this once it's
working.

   xx
  x..x
  x..x
   xx

3: x
  x.x
   x
