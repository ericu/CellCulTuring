Simple buffer:    Depth buffer: [Or 1-3, with 0 meaning not-in-buffer].
 . . . . .          . . . . .
 . : : : .          . 2 1 1 .
 . : : : .          . 2 1 0 .
 . : : : p          . 2 1 0 p
 . : : : p          . 2 1 0 p
 . : : : p          . 2 1 0 p

In the buffered cases, how does this look?

Simple buffer hit:

b  b  b  .  .       .  .  .  .  .
b  b: b:  :  .      .  b: b: b:  .
b  b: b:  :  .      .  b: b: b:  .
.   :  :  :  p  ->  .  b: b: b:  p
.   :  :  :  p      .   :  :  :  p
.   :  :  :  p      .   :  :  :  p

All ball cells going into the simple buffer know it, since the buffer moves
into cells at the same 1 cell per cycle that the ball cells do.  Ball cells
can spread depth knowledge as well.  Hmm...but if they come from above, do
they need to know depth-to-X as well as depth-to-Y?  Probably.  Can they tell
that?  In the special case of depth 3, yes, because a cell can tell which
buffer cell it is by its neighbors.  If there were a 4+ thickness buffer, the
inner cells would be indistinguishable.

OK, review: how do we know Y depth in the simple case above?  The buffer region
will have to have the same PADDLE_PIXEL, extended to the whole region, in order
to have the correct bounce angle, so we'll use that.  So it'll really be a depth
buffer, at least in Y, automatically.  We could use a 4-pixel paddle with a
2-pixel buffer top and bottom, and that'd be the same 3 bits and 8 rows of
coverage.

Simple buffer barely-miss:
b  b  b  .  .       .  b  b  b  .
b  b: b:  :  :      .  b: b: b:  :
b  b: b:  :  :      .  b: b: b:  :
.   :  :  :  p  ->  .   :  :  :  p
.   :  :  :  p      .   :  :  :  p
.   :  :  :  p      .   :  :  :  p

Here the y-depth is 2 and the x-depth 3, so it's a miss.

State in the paddle and buffer:
  IsPaddle/IsPaddleBuffer:
    2 global ID bits, 2 for buffers, 1 for paddle buffer
  IsRightNotLeft:1
  paddlePixel pixel:3-4, depending on size
  Where-am-I location:6
  Where-am-I-going counter/altitude:3
  When-can-I-leave [counter for info to propagate through thickness of paddle]:3

All that state needs to get stored in the ball as well, since it needs to be
restored as the ball moves away.  Hmm...or can we just restore it from the
neighboring paddle cells?  That would save a lot of bits in the ball, which
probably has other uses for them.  Seems likely that we can do that; it's a
bit more complex, but worth it.  Umm...actually no, not without storing the
depth bits as well, otherwise the left edge of the right paddle buffer, coming
down out from under a ball, doesn't know where its top border is.  Still, we
can pull the counters from our paddle-cell neighbors, just not the single bit
for IsPaddleBuffer.  Oops--that's problematic as well, with larger balls.  If
you've got a paddle buffer inside a ball, it needs to know its movement
parameters, and can't pull them from neighbors if it's deep inside the ball.
Note that movement parameters don't change when there's a ball around, though,
nor will an AI paddle reverse directions while we're near it.  And the non-AI
paddle will get special treatment that should make things easier and not require
extra bits.

Example bit allocations for a 3-pixel ball and a height-64 [so 6 bits] board

Global: 2: type [isBall, isBackground, isAIPaddle, isWall]
  We can possibly use a lower bit from isBackground or isWall and use it for the
  non-AI paddle.
  Total: 2
Ball: 2:depthX, 2:depthY, 1:down, 1:right, 3:moveIndex, 2:moveState, 1:decimator
  [shared with paddle]. Do we need another 2 bits for depthYIntoPaddleBuffer?
  Probably.
  Total: 12-14
Paddle/PaddleBuffer: 6:height, 3:dest, 2:moveSyncDelayCounter, 3:pixel [assumes
  a 4-pixel paddle with 8-pixel-tall containing buffer], 1:paddleBallSignal [is
  that needed with a big ball?  Not if the paddle is flush with the wall.],
  1:decimator, 1:isBuffer.  We'll either have to save/restore the Y buffer or
  we'll have to figure it out from height and pixel...yeah, we can do that, and
  save the bit.
  Total: 16-17 [1 shared with ball]
Background/Buffer: 4:bufferFlags
  Total: 4

The ball needs to hold all the paddle buffer bits as it goes through, otherwise
a corner of the buffer, coming out from under the ball, won't have anywhere to
grab them from.  So 14 ball bits plus 16 - 1 is 29 shared bits, plus 2 ID bits,
so it's doable with maybe a bit to spare.

What about the AI message?  It should get generated from a background cell that
sees 3 ball cells stacked vertically to its side, newly-bounced, with the full
paddle depths set.  And the respawn message gets generated by a wall cell that
sees wall above and below and 3 ball cells next to it.

DepthX and depthXIntoPaddleBuffer would be different, since the paddle
is 1 pixel in from the wall, but we could cheat that by making the paddle
collinear with the wall, and then just keeping track of the single bit of
whether we're in the paddle buffer or not, which might possibly be shared with
the depthYIntoPaddleBuffer.  Hmm...if we've got a separate bit for
depthXIsInPaddleBuffer somehow, then we count up to 3 for depth and then bounce,
or overflow the 2 bits to 4, meaning we missed.  That could work even without
flush paddle.  However, flush paddle saves us from needing PADDLE_BALL_SIGNAL.

Unrelated: the ball needs to recognize where it's hit on the paddle in order
to know what angle to bounce off.  That indicates that we're going to need a
marker in the paddle and buffer to tell the ball how to bounce.  With a ball
of only 3 pixels, each pixel should be able to tell which one it is, so at
least the ball knows itself.  But it implies another field, of at least
log(PADDLE_SIZE) bits, in both paddle field and ball.  And PADDLE_SIZE must be
at least 4 pixels [defending 6 positions] to be playable.  But perhaps we can
use depthYIntoPaddleBuffer for this?  If we're at full depth, it's a straight
bounce, otherwise it's one of two angles, and we can't tell if it should be up
or down.  Not good.

And let's not forget that the ball will have to hit the human-driven paddle on
the other side, which will move even more erratically, and will probably
require the buffer region.

Message-passing: the background passes info for the AI sideways; it'll need
a direction indicator as well as the target offset.
The end walls pass scoring info outward to the scoreboard, and must also pass
the ball-spawn message to the respawn point.  Perhaps we should have 2 respawn
points, one on each side.  Pass the message up to the top, along the wall,
then down to the respawn point.  It would be good if the respawn happened
after the score increment.  It would also be good if the score on the left
corresponded to the paddle on the left, although if I want the score to count
up, which I do, that's tricky.  So scoring messages have to get across to a
scoreboard on the opposite side, then respawn the ball on the way back,
perhaps?


      -----------------------------------------------------------
 S S  |                                                         | S S
      |                                                         |
      |                                                        P|
      |                                                        P|
      |                                  B                     P|
      |                                                         |
      |P                                                        |
      |P                                                        |
      |P                                                        |
      |                                                         |
      |                                                         |
      -----------------------------------------------------------


Here the scores are at the top-center.  Let's make the message wave
visible, so you can watch it move up the wall, to the center.  There it splits
and sends a scoring message up to the scoreboard [saying which player to
increment] and down to the respawn point.  We can either send the score the
whole way there, in which case the walls have to know the score through their
whole length, or we can just send an increment, in which case it's hard to know
when the game ends before respawning.

The respawn point can also be the center of a "game over" message if the message
splitter at the top keeps track of when the game ends.

                            | S S  |  S S  |
      -----------------------------------------------------------
      |                            |                            |
      |                            |                            |
      |                            |                           P|
      |                            |                           P|
      |                            |     B                     P|
      |                            r                            |
      |P                                                        |
      |P                                                        |
      |P                                                        |
      |                                                         |
      |                                                         |
      -----------------------------------------------------------

Bits we want visible:
isBall, isWall, isPaddle, counter + message displays, the scoring message
moving up the wall from a ball impact.
Bits we want invisible or at least unobtrusive:
The AI message.
Bits I'm not sure about yet:
The ball respawn message coming down from the top.

Counter messages through the counter region:
  Direction bit for routing: No, all directions.
  Spread: all directions
  Payload: score counter, likely 4 bits.

Board layout:

We'll need to interpret the ball-hit message before the respawn, so that we
don't respawn on game over.  We can do that at the top-wall-center pixel.  If it
keeps track of the score of each player, it can decide when the game is over and
either send the respawn message or not.  It can also initiate the game-over
message, wherever we want to display that.

So top-wall-center needs, in addition to 2 type bits, 1 subtype bit, and 2
message bits [present + direction] a counter for each score, say at least 4 bits
with game going to 15.  Messages will always go up, and will only go down on
score less than the max, so we'll need a separate signal for up messages vs.
down, so at least 1 more bit there for message and a second for game-over.
That's still only 15 or so, so no problem there.

----------------------------------------------------------------
|       1 4         |   G A M E   O V E R   |       0 3        |
----------------------------------------------------------------
|                                                              |
|                                                              |
|                                                              |
|                                                              |
|                                                              |
|                                                              |
|                                                              |
----------------------------------------------------------------

Here the GAME OVER is in the middle, which looks good, but if the message comes
from the middle, it would naturally appear before the final score increment.  
We can put a delay in there by using the counter display for the game over; just
have the whole message trigger on a high number, and have the message trigger a
single-cell counter that counts up to it and then stops there.

Another option for game-over and score/respawn messages: the message comes up
from the paddle, across all the way to the opposite score [as its direction
tells the fork under each score whether to grab it or not], up into the score,
and then spreads out, hitting the border of game-over.  game-over looks for a
score increment, and lights up on the final score.  There's a cell at its bottom
center that sees an increment that's not the final score, and triggers a
straight-down respawn message with LR in it.  We'd just need a few wall subtypes
to deal with the routing.
