Message systems:

AI messages through the background:
  Direction bit for routing: L/R.
  Spread: vertical
  Payload: 6 bit location.

Ball-hit messages through the walls:
  Direction bit for routing: L/R.
  Spread: vertical
  Payload: just the direction bit is enough info.

Counter messages through the counter region:
  Direction bit for routing: No, all directions.
  Spread: all directions
  Payload: score counter, likely 4 bits.

Respawn messages through the background:
  Direction bit for routing: No, always down.
  Spread: no
  Payload: just the message is enough info.

Do we need a general message bus?  So far we have enough bits for each of these,
that's been implemented, but we haven't done the AI message or overlaid it on
the respawn message.  Let's count bits for separate comms:

Major type: 2
  isBall, isWall, isPaddle, isBackground.
  Subtypes:
    Wall:
      side wall [can tell which side ball came from, so single type is enough]
      top wall
      top wall center
    Paddle:
      user L/R
      AI L/R
    Background:
      message down [or does this even need to be separate?]
      respawn

Ball:
  LR:1, UD:1, index:3, state:2

Background:
  Respawn message: present: 1, LR: 1


The most complicated messages happen in the background.  Background messages
never need to pass through the ball, so ignore those interactions.  Ideally we'd
have no retained background bits for the ball to have to carry, but at the very
least it'll have to restore the respawn cell.  Let's see if we can get rid of
the message-down cells.

So messages have 2 direction bits.  LR messages go that direction and spread. D
messages just go down and don't spread.  The messages have a payload.  LR
messages have a 6-bit counter.  D messages just need to exist, so they need no
payload.  That takes care of it.


Math for AI messages:

Board is B_W by B_H.  Angles are 0, 1/3, 1/2, 2/3, 1, 3/2, 2, 3.

m is slope, dX is B_W
dY = m dX

if (m is zero)
  offset is zero
else
  dY = m dX
  y = Y0 + dY
  clippedY = y % B_H
  if is_odd(floor(y / B_H))
    finalY = B_H - clippedY
  else
    finalY = clippedY

Bounce angles:

  Try a paddle height of 8 pixels.
  Output angle for bounce at a given height on the paddle:

  0: 3
  1: max(input angle + 3 indices, 3)
  2: max(input angle + 1 indices, 3)
  3: -input angle
  4: -input angle
  5: min(input angle - 1 indices, -3)
  6: min(input angle - 3 indices, -3)
  7: -3

Who sends out the AI message?  Ideally it would be the paddle cells just above
and below the ball hit, so that the message was guaranteed to get around the
ball on at least one side, even if it hit at the edge:

[p*][  ]
[p ][b ]
[p*][  ]
[p ][  ]

Oooh, and does this count as a hit, if the ball's moving up and to the left?

[  ][  ]
[p ][b ]
[p ][  ]
[p ][  ]

It should, since it looks like a hit; it shouldn't matter where the ball's
aiming.  Count the hit when it's at the edge, not when it would penetrate it.
What about on slope-3, though, where it can go straight up along the side and
then dart in?  OK, it's when it would penetrate the surface, but it bounces if
there's something next to it now, not where it's going to be?  Yeah, that seems
pretty good.  So a paddle cell looks for a ball next to it, with a dX that would
penetrate, no matter what dY is.

But then those cells need to note an incoming ball that's not hitting them, and
notice that it's hitting a valid paddle cell.  That's not too bad, but it's a
little cumbersome to compute.  Can we have just the hit cell send the message?
Yes, that should work, as long as it spreads immediately.

[  ][  ][  ]      [  ][  ][  ]      [  ][  ][  ]
[p ][  ][  ]      [p ][  ][  ]      [p ][ *][b ]
[p ][  ][  ]  =>  [p*][b ][  ]  =>  [p ][ *][  ]
[p ][  ][b ]      [p ][  ][  ]      [p ][ *][  ]
[p ][  ][  ]      [p ][  ][  ]      [p ][  ][  ]

Except of course that AI messages go at twice the speed of a ball, so it'd look
more like this:

[  ][  ][  ]      [  ][  ][  ]      [  ][  ][  ]      [  ][  ][ *]
[p ][  ][  ]      [p ][  ][  ]      [p ][ *][  ]      [p ][b ][ *]
[p ][  ][  ]  =>  [p*][b ][  ]  =>  [p ][b ][  ]  =>  [p ][  ][ *]
[p ][  ][b ]      [p ][  ][  ]      [p ][ *][  ]      [p ][  ][ *]
[p ][  ][  ]      [p ][  ][  ]      [p ][  ][  ]      [p ][  ][ *]

Oops!  What if the paddle cell that's supposed to send the message is at the
edge, and the paddle moves away from it, so it's gone?  We'll have to send
from multiple cells; either both corners or all 3 of the side will work.

Board layout:

We'll need to interpret the ball-hit message before the respawn, so that we
don't respawn on game over.  We can do that at the top-wall-center pixel.  If it
keeps track of the score of each player, it can decide when the game is over and
either send the respawn message or not.  It can also initiate the game-over
message, wherever we want to display that.

----------------------------------------------------------------
|       1 4         |   G A M E   O V E R   |       0 3        |
----------------------------------------------------------------
|                                                              |
|                                                              |
|                                                              |
|                                                              |
|                                                              |
|                                                              |
|                                                              |
----------------------------------------------------------------

Here the GAME OVER is in the middle, which looks good, but if the message comes
from the middle, it would naturally appear before the final score increment.  
We can put a delay in there by using the counter display for the game over; just
have the whole message trigger on a high number, and have the message trigger a
single-cell counter that counts up to it and then stops there.

function getIncomingBall(data) {
  for (let i = 0; i < 9; ++i) {
    let color = data[i];
    if (isBall(color)) {
      let ms = new MotionState(bm, color);
      let source = sourceDirectionFromIndex(i);
      if (source.dX !== ms.dX || source.dY !== ms.dY) {
        return null; // There's only 1 ball; exit early.
      }
      return { index: i, ms: ms } // Is index needed?
    }
  }
}

function paddleBounce(data) {
  const current = data[4];

  let incomingBall = getIncomingBall(data);

  if (isWall(current)) {
  } else if (isPaddle(current)) {
    const curLoc = getBits()
    const dstLoc = getBits()
    if ((curLoc > dstLoc && isPaddle(data[1])) ||
        (curLoc < dstLoc && isPaddle(data[7]))) {
      // update curLoc and fall through
    } else {
      // If we're background we're not sending AI messages and not receiving
      // them, so we can exit early.
      return BACKGROUND;
    }

    // send AI message if there's a ball hitting just above or below us
    for (let index of [0, 2, 6, 8]) {
      let color = data[index];
      if (isBall(color)) {
        let ms = new MotionState(bm, color);
        let paddleAbove = isPaddle(data[1]);
        let paddleBelow = isPaddle(data[7]);
        let ballOnLeft = index === 0 || index === 6;
        let ballAbove = index === 0 || index === 2;
        let ballApproaching =
          (ballOnLeft && ms.dX > 0) || (!ballOnLeft && ms.dX < 0);

        if (ballApproaching &&
            ((ballAbove && paddleAbove) || (ballBelow && paddleBelow))) {
          // TODO Set the message flag, with direction based on paddleCellIndex
          // and ms.
        }
      }
    }

    // receive AI message: TODO
    for (let index of [0, 2, 3, 5, 6, 8]) {
      let m = getMessage(index);
      if (m && sourceDirectionFromIndex(index).dX === m.direction) {
        // Set our dst to be the m.value
        // This affects our future motion, but not this cycle's motion.
      }
    }

  } else if (isBall(current)) {
  } else {
  }
